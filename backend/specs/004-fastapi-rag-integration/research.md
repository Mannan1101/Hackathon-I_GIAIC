# Research: FastAPI RAG Integration

**Feature**: 004-fastapi-rag-integration
**Date**: 2025-12-28
**Purpose**: Document architectural decisions and technical research for integrating the RAG agent with FastAPI

---

## 1. FastAPI Integration Patterns

### Decision: Async Endpoint with Sync Agent Wrapper

**Rationale**:
- The existing `agent.py` uses async functions (`async def query_agent()`)
- FastAPI supports both sync and async endpoints natively
- Async endpoints provide better concurrency handling for I/O-bound operations like LLM calls

**Pattern Selected**:
```python
@app.post("/chat")
async def chat_endpoint(request: ChatRequest) -> ChatResponse:
    """Async endpoint that directly awaits the agent's async execution"""
    answer = await query_agent(request.question)
    return ChatResponse(answer=answer)
```

**Alternatives Considered**:
1. **Sync endpoint with `asyncio.run()`** - Rejected: Creates new event loops, not compatible with Uvicorn's existing loop
2. **Background tasks** - Rejected: Unnecessary complexity for request-response pattern
3. **Celery/task queue** - Rejected: Over-engineering for local development scope

**CORS Configuration**:
```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Docusaurus dev server
    allow_credentials=True,
    allow_methods=["POST"],
    allow_headers=["Content-Type"],
)
```

**Logging Integration**:
- Reuse existing logging setup from `agent.py`
- Add structured logging for API requests (endpoint, status, duration)
- Log errors with full traceback for debugging

---

## 2. Agent Invocation Strategy

### Decision: Single-Turn Stateless Queries with Optional Session Support

**Rationale**:
- Frontend sends one question per request without conversation context
- Agent already supports both single-turn (`query_agent()`) and multi-turn (SQLiteSession)
- Spec explicitly states "single-turn conversations" for MVP
- Session management adds complexity not required by current frontend

**Implementation Approach**:
```python
async def query_agent(question: str) -> str:
    """
    Invoke the RAG agent with a single question.
    Returns the answer as a string.
    """
    # Create a new agent instance per request (stateless)
    agent = create_book_agent()

    # Use Runner with in-memory session (no persistence needed)
    runner = Runner(agent=agent)

    # Execute the query
    result = await runner.run(question)

    # Extract final answer text
    return result.final_answer
```

**Session Management**:
- Phase 1: No session persistence (stateless)
- Future enhancement: Support session IDs in request for conversation history

**Timeout Handling**:
- Set FastAPI route timeout: 30 seconds (conservative, allows 10s agent + 20s buffer)
- Agent-level timeout: Rely on OpenRouter API timeouts
- Return 504 Gateway Timeout if agent exceeds threshold

**Agent Lifecycle**:
- Create agent instance per request (lightweight, no global state)
- Agent initialization is fast (model already loaded, retriever initialized)
- Alternative: Global agent instance (premature optimization, adds state management complexity)

---

## 3. Request/Response Format

### Decision: Minimal JSON Matching Frontend Contract

**Frontend Expectation** (from `src/components/Chatbot/index.js`):
```javascript
// Request
await fetch('http://127.0.0.1:8000/chat', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ question }),
});

// Response
const data = await res.json();
console.log(data.answer);  // Expects { answer: "..." }
```

**API Contract**:

**Request Schema**:
```python
from pydantic import BaseModel, Field

class ChatRequest(BaseModel):
    question: str = Field(..., min_length=1, max_length=1000,
                          description="User's question about the textbook")
```

**Success Response Schema**:
```python
class ChatResponse(BaseModel):
    answer: str = Field(..., description="Agent's response to the question")
    sources: list[str] | None = Field(None, description="Optional: Retrieved document chunks")
```

**Error Response Schema**:
```python
class ErrorResponse(BaseModel):
    error: str = Field(..., description="Error type (validation_error, agent_error, server_error)")
    message: str = Field(..., description="Human-readable error description")
    detail: dict | None = Field(None, description="Additional error context")
```

**HTTP Status Codes**:
- **200 OK**: Successful agent response
- **400 Bad Request**: Empty or invalid question (validation failure)
- **422 Unprocessable Entity**: Pydantic validation error (auto-generated by FastAPI)
- **500 Internal Server Error**: Agent execution failure, retrieval error, unexpected errors
- **504 Gateway Timeout**: Query exceeded timeout threshold

**Optional Metadata** (Phase 2 enhancement):
- `sources`: List of retrieved document chunks with citations
- `confidence`: Agent confidence score
- `retrieval_time`: Time spent on retrieval
- `generation_time`: Time spent on LLM generation

---

## 4. Deployment & Development Workflow

### Decision: Uvicorn with Hot Reload for Local Development

**Development Server Configuration**:
```python
# In api.py
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "api:app",
        host="127.0.0.1",
        port=8000,
        reload=True,  # Auto-reload on code changes
        log_level="info"
    )
```

**Alternative: CLI Command**:
```bash
uvicorn api:app --host 127.0.0.1 --port 8000 --reload
```

**Environment Variable Management**:
- Reuse existing `.env` file from agent.py
- Required variables:
  - `OPENROUTER_API_KEY`
  - `QDRANT_API_KEY`
  - `QDRANT_URL`
- Load with `python-dotenv` at app startup
- Provide `.env.example` with placeholders

**Port Configuration**:
- **Fixed Port**: 8000 (hardcoded in frontend)
- Frontend expects: `http://127.0.0.1:8000/chat`
- No configuration needed (convention over configuration)

**Hot Reload**:
- Uvicorn's `--reload` flag watches for Python file changes
- Agent code changes (`agent.py`, `retrieve_main.py`) trigger reload
- Improves developer experience during iterative development

**Startup Sequence**:
1. Start backend: `python api.py` (or `uvicorn api:app --reload`)
2. Start frontend: `npm start` (from project root)
3. Access chatbot: Navigate to any Docusaurus page

---

## 5. Error Handling Strategy

### Decision: Comprehensive Try-Catch with Structured Error Responses

**Error Handling Layers**:

1. **Input Validation** (FastAPI/Pydantic):
   - Automatic validation via Pydantic models
   - Returns 422 with detailed validation errors
   - No custom code needed

2. **Agent Execution Errors**:
```python
try:
    answer = await query_agent(request.question)
    return ChatResponse(answer=answer)
except TimeoutError:
    raise HTTPException(status_code=504, detail="Query timeout")
except Exception as e:
    logger.error(f"Agent error: {e}", exc_info=True)
    raise HTTPException(
        status_code=500,
        detail={"error": "agent_error", "message": str(e)}
    )
```

3. **Retrieval Errors**:
   - Caught within agent execution
   - Logged and converted to user-friendly message
   - Return partial response if generation succeeds but retrieval fails

4. **Dependency Errors**:
   - Vector DB connection failure → 500 with "Vector database unavailable"
   - LLM API failure → 500 with "LLM service unavailable"

**Logging Strategy**:
- Log all requests with: timestamp, endpoint, question (truncated), duration, status
- Log errors with full stack trace
- Use structured logging (JSON format) for easy parsing

---

## 6. Testing Strategy

### Decision: Pytest with FastAPI TestClient

**Test Layers**:

1. **Unit Tests** (`test_api.py`):
   - Test request validation (valid/invalid inputs)
   - Test response serialization
   - Mock agent to test API logic in isolation

2. **Integration Tests** (`test_integration.py`):
   - Test full flow: request → agent → response
   - Requires running vector DB and populated data
   - Test error scenarios (agent failure, timeout, etc.)

3. **Contract Tests**:
   - Verify API matches OpenAPI spec
   - Validate request/response schemas
   - Ensure frontend compatibility

**Test Setup**:
```python
from fastapi.testclient import TestClient
from api import app

client = TestClient(app)

def test_chat_endpoint_success():
    response = client.post("/chat", json={"question": "What is physical AI?"})
    assert response.status_code == 200
    assert "answer" in response.json()

def test_chat_endpoint_empty_question():
    response = client.post("/chat", json={"question": ""})
    assert response.status_code == 422  # Validation error
```

---

## 7. Dependencies

### Decision: Minimal FastAPI Stack

**New Dependencies** (add to `pyproject.toml`):
```toml
[project]
dependencies = [
    "fastapi>=0.115.0",
    "uvicorn[standard]>=0.32.0",
    "python-dotenv>=1.0.0",  # Already exists
    "pydantic>=2.0.0",       # Bundled with FastAPI
]

[project.optional-dependencies]
dev = [
    "pytest>=8.0.0",
    "httpx>=0.27.0",  # TestClient dependency
]
```

**Rationale**:
- `fastapi`: Core framework
- `uvicorn[standard]`: ASGI server with websockets and performance extras
- `python-dotenv`: Environment variable loading (already used in agent.py)
- `pydantic`: Request/response validation (bundled with FastAPI)

**Existing Dependencies Reused**:
- `openai-agents`: Agent SDK
- `qdrant-client`: Vector DB client
- `openai`: LLM client

---

## 8. Architecture Decision Records (ADRs)

### ADR-001: Use FastAPI Instead of Flask

**Context**: Need a Python web framework for REST API

**Decision**: Use FastAPI

**Rationale**:
- Native async/await support (agent is async)
- Automatic OpenAPI documentation generation
- Pydantic integration for request/response validation
- Better performance than Flask for async workloads
- Modern, actively maintained

**Alternatives**:
- Flask: Requires async extensions (Flask-Async), less ergonomic for async code
- Django: Over-engineered for simple API wrapper
- Starlette: FastAPI is built on Starlette, provides higher-level abstractions

**Status**: Accepted

---

### ADR-002: Stateless Single-Turn Queries for MVP

**Context**: Agent supports multi-turn conversations with SQLiteSession

**Decision**: Implement stateless single-turn queries without session persistence

**Rationale**:
- Frontend sends one question per request (no conversation ID)
- Spec explicitly scopes to "single-turn conversations"
- Simplifies implementation (no session management)
- Easier to test and debug
- Can add sessions later without breaking changes

**Alternatives**:
- Multi-turn with session IDs: Requires frontend changes, out of MVP scope
- In-memory conversation history: Doesn't persist across server restarts

**Status**: Accepted (with future enhancement path for multi-turn)

---

### ADR-003: CORS Enabled for Localhost Origins

**Context**: Frontend and backend run on different ports during development

**Decision**: Enable CORS for `http://localhost:3000` (Docusaurus dev server)

**Rationale**:
- Docusaurus runs on port 3000, API on port 8000
- Browser enforces same-origin policy
- CORS middleware is standard FastAPI pattern

**Security Considerations**:
- Restricted to localhost origins only
- Production deployment would require updating allowed origins

**Status**: Accepted

---

## Summary of Key Decisions

| Area | Decision | Rationale |
|------|----------|-----------|
| **Framework** | FastAPI with Uvicorn | Native async, auto docs, Pydantic validation |
| **Agent Invocation** | Stateless single-turn | Matches frontend contract, simpler MVP |
| **Request Format** | `{question: str}` | Matches existing frontend expectation |
| **Response Format** | `{answer: str}` | Minimal contract, extensible for metadata |
| **Error Handling** | Try-catch with HTTP exceptions | Structured errors, detailed logging |
| **CORS** | Enabled for localhost:3000 | Required for local development |
| **Session Management** | None (stateless) | Out of MVP scope, future enhancement |
| **Testing** | Pytest + TestClient | Standard FastAPI testing approach |
| **Deployment** | Local Uvicorn with hot reload | Developer-friendly, matches spec scope |

---

## Next Steps (Phase 1)

1. Create `data-model.md` with formal Pydantic schemas
2. Generate `contracts/api-spec.yaml` OpenAPI specification
3. Write `quickstart.md` developer guide
4. Update agent context with FastAPI usage
5. Proceed to `/sp.tasks` for RED-GREEN-REFACTOR implementation
